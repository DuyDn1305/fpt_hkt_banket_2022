import Person "person";
import Debug "mo:base/Debug";
import HashMap "mo:base/HashMap";
import Principal "mo:base/Principal";
import Cycles "mo:base/ExperimentalCycles";
import Trie "mo:base/Trie";
import Nat "mo:base/Nat";
import Hash "mo:base/Hash";

actor {
  /// Custom type
  // public type Person = Person.Person;
  // let quynh : Person = {
  //   name = "Nhat Quynh";
  //   age = 27;
  // };
  // public func Test(){
  //   let quynh_name = quynh.name;
  //   let quynh_age = quynh.age;
  //   Debug.print(debug_show(quynh_name));
  //   Debug.print(debug_show(quynh_age));
  // };

  /// Linked List
  public type List<T> = ?(T, List<T>);
  public func is_list_null(list : List<Nat>) : async Text{
    switch(list){
      case(null){
        return "The list is null ... üôÅ"
      };
      case(?list){
        return "this list is not null"
      };
    }
  };

  /// Get Principal ID
  /// shared(msg) : share the info of the caller
  public shared(msg) func whoami() : async Principal{
    /// Msg contains Principal caller
    let principal_caller = msg.caller;
    return (principal_caller);
  };

  /// HashMap Data Structure
  let anonymous_principal : Principal = Principal.fromText("2vxsx-fae");
  let users = HashMap.HashMap<Principal, Text>(0, Principal.equal, Principal.hash);
  users.put(anonymous_principal, "This is the anonymous principal");

  public func test() : async ?Text {
    return(users.get(Principal.fromText("2vxsx-fae")));
  };

  /// Cycles

  public func balance() : async Nat{
    return (Cycles.balance());
  };
  public func message_available() : async Nat {
    return(Cycles.available())
  };

  /// Stable variables
  stable var my_name : Text = "";

    public func change_name(name : Text) : async () {
        my_name := name;
    };

    public func show_name() : async Text {
        return(my_name)
    };

  // // Variant  

  // Trie
  // CRUD with Trie
  type Person = {
    name : Text;
    age : Nat;
    address : Text;
    sex : Bool;
  };

  // aplication state
  stable var persons : Trie.Trie<Nat, Person> = Trie.empty();
  stable var next : Nat = 0;

  // create key
  private func key(x : Nat) : Trie.Key<Nat>{
    return{
      key = x;
      hash = Hash.hash(x);
    };
  };

// Write create function 
  public func create_account(p : Person) : async Bool {
    next += 1;
    let id = next;
    // put method
    let (newPersons, existing) = Trie.put(
    persons,
    key(id),
    Nat.equal,
    p);
    switch(existing) {
      // if there is no match
      case (null) {
         persons := newPersons;
      };
      // Match
      case(?v) {
        return false;
      };
    };
    return true;
  };

  //Write read function
  public func read_account(id : Nat) : async ?Person {
    let result = Trie.find(
      persons,key(id),Nat.equal
    );
    return result;
  };

  // Write update function
  public func update_account(id : Nat, person : Person) : async Bool {
    let result = Trie.find(
      persons,key(id),Nat.equal
    );
    switch(result) {
      // Not update
      case (null) {
        return false;
      };
      case (?v) {
        persons := Trie.replace(
          persons,key(id),Nat.equal,?person
        ).0;
      };  
    };
    return true;
  };

  // Write delete function
  public func delete_account(id : Nat) : async Bool {
    let result = Trie.find(
      persons,key(id),Nat.equal
      );
      switch(result) {
        // Not update
        case (null) {
          return false;
        };
        case (?v) {
          persons := Trie.replace(
            persons,key(id),Nat.equal,null
          ).0;
        };  
      };
      return true;
  };
};